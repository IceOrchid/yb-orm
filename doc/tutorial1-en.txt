=== Mapping single class to table (tut1.cpp) ===
Describe table structure in schema XML file.

 <nowiki><schema> </nowiki>
     <nowiki><table name="client" sequence="seq_client" class="Client"> </nowiki>
         <nowiki><column name="id" type="longint"> </nowiki>
             <nowiki><primary-key /> </nowiki>
         <nowiki></column> </nowiki>
         <nowiki><column name="dt" type="datetime" null="false" default="sysdate" /> </nowiki>
         <nowiki><column name="name" type="string" size="100" null="false" /> </nowiki>
         <nowiki><column name="email" type="string" size="100" null="false" /> </nowiki>
         <nowiki><column name="phone" type="string" size="50" null="true" /> </nowiki>
         <nowiki><column name="budget" type="decimal" /> </nowiki>
     <nowiki></table> </nowiki>
 <nowiki></schema> </nowiki>

Then use domain class generator utility to create C++ classes. The first argument is the file name of schema, the second is the directory to put the generated files to, the third (optional) is directory prefix for the <tt><nowiki>#include</nowiki></tt> directive (by default: <tt>domain/</tt>).

 $(YBORM_ROOT)/bin/yborm_gen_domain tutorial/tut1.xml domain

If necessary, use script for SQL DDL generation, it will help create tables and sequences. When invoking that script specify the SQL dialect. As of now, the following are supported: MYSQL, POSTGRES, ORACLE, INTERBASE.

 $(YBORM_ROOT)/bin/yborm_gen_sql MYSQL tutorial/tut1.xml

It will produce SQL code like this:

 CREATE TABLE client ( 
     id BIGINT NOT NULL AUTO_INCREMENT, 
     dt TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP, 
     name VARCHAR(100) NOT NULL, 
     email VARCHAR(100) NOT NULL, 
     phone VARCHAR(50), 
     budget DECIMAL(16, 6), 
     PRIMARY KEY (id) 
 ) ENGINE=INNODB DEFAULT CHARSET=utf8; 

Now its possible to use domain class <tt>Client</tt>. Let's look at the example. To synchronize objects to the DB an instance of <tt>Yb::Session</tt> class is used. As an abstraction layer for SQL there are classes <tt>Yb::Engine</tt> and <tt>Yb::SqlConnect</tt>. In the example below you see the session initialization, then a new instance of mapped class created and its properties are filled, then it's stored in session and pushed down to the DB. During the synchronization the object is assigned an ID.

 <nowiki>#include <memory> </nowiki>
 <nowiki>#include <iostream> </nowiki>
 <nowiki>#include <orm/MetaDataSingleton.h> </nowiki>
 <nowiki>#include "domain/Client.h" </nowiki>
 using namespace std; 
 
 int main() 
 { 
     <nowiki>auto_ptr<Yb::SqlConnect> conn( </nowiki>
         new Yb::SqlConnect("ODBC", "MYSQL", "test1_db", "test1", "test1_pwd")); 
     Yb::Engine engine(Yb::Engine::MANUAL, conn); 
     Yb::Session session(Yb::init_default_meta(), &engine); 
     Domain::Client client; 
     string name, email, budget; 
     <nowiki>cout << "Enter name, email, budget:\n"; </nowiki>
     cin >> name >> email >> budget; 
     client.set_name(name); 
     client.set_email(email); 
     client.set_budget(Yb::Decimal(budget)); 
     client.set_dt(Yb::now()); 
     client.save(session); 
     session.flush(); 
     <nowiki>cout << "New client: " << client.get_id() << endl; </nowiki>
     engine.commit(); 
     return 0; 
 }

When building the example you'll need to link against the following libraries <tt>$(YBORM_ROOT)/lib/libyborm.so</tt>, <tt>$(YBORM_ROOT)/lib/libybutil.so</tt>, as well as its dependencies <tt>-lodbc</tt>, <tt>-lxml2</tt>, <tt>-lboost_thread</tt>, <tt>-lboost_date_time</tt>. If you are building example from <tt>tutorial</tt> folder you should look in <tt>Makefile.am</tt>.

In this example the ODBC backend is used. Therefore to make it work it's necessary to setup corresponding DSN in local (<tt>~/.odbc.ini</tt>) or in global (<tt>/etc/odbc.ini</tt>) configuration file.

 <nowiki>[test1_db]</nowiki>
 Description     <nowiki>= Test database 1</nowiki>
 Driver          <nowiki>= MyODBC</nowiki>
 Server          <nowiki>= localhost</nowiki>
 Database        <nowiki>= test1_db</nowiki>
 Port            <nowiki>= </nowiki>
 Socket          <nowiki>= </nowiki>
 Option          <nowiki>= 3</nowiki>
 Stmt            <nowiki>= </nowiki>
 CharSet         <nowiki>= UTF8</nowiki>

Should you trace the SQL statements being executed you'll see the following (given that you use MYSQL):

 INSERT INTO client (dt, name, email, phone, budget) VALUES (?, ?, ?, ?, ?);
 SELECT LAST_INSERT_ID() LID;
 COMMIT;

If you connect to Oracle database then you'll see a different trace:

 SELECT seq_client.NEXTVAL FROM DUAL;
 INSERT INTO client (id, dt, name, email, phone, budget) VALUES (?, ?, ?, ?, ?, ?);
 COMMIT;
