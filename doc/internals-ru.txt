=== Реализация отношения «1 к n» ===
Изложу мою точку зрения на то, каким образом можно реализовать отображение отношения «1 к n». Сторона «1» - главная таблица, в то время как сторона «n» соответствует подчинённой (дочерней) таблице. Предположим, что нам хочется уметь манипулировать отношением с обеих сторон. С подчинённой стороны это отношение будет выглядеть как свойство-объект, и этот связанный объект, вероятно, можно устанавливать/менять/очищать. Со стороны главной таблицы то же отношение будет выглядеть как некое свойство-коллекция, которая позволяет по ней итерировать/добавлять/удалять ссылки на объекты. Так как любые изменения, сделанные с одной стороны, должны немедленно стать доступны с другой стороны этого отношения, то мы имеем следующие возможности достичь этого:

# Проталкивать изменения всем участникам данного отношения немедленно. В этом случае свойство-коллекция, о котором уже говорилось, можно было бы реализовать на основе контейнеров общего назначения, переопределив методы для модификации контейнера.
# Можно ввести промежуточный объект «экземпляр отношения», который будет владеть всей информацией о данном отношении для ровно одного экземпляра главной сущности. Тогда все запросы к свойствам с любой стороны отношения будут доставать данные из этого промежуточного объекта.

Чтобы выбрать между этими способами нужно ответить на несколько важных вопросов:

# Как будут создаваться экземпляры отображаемых классов? Можно ли создать экземпляр отдельно без вставки его в реестр <tt>IdentityMap</tt>? Как насчёт создания связной структуры из новых объектов?
# Можно ли копировать экземпляры отображённых классов, при этом сохраняя знание о других экземплярах, чтобы потом иметь возможность протолкнуть изменения? Или может быть нам следует иметь единственный экземпляр для каждой записи?
# Кто отвечает за удаление объектов во всех возможных сценариях? 

В любом случае есть механизмы, которые обычно используются в любом ORM-подобном решении. Например, паттерн <tt>IdentityMap</tt> подразумевает, что все экземпляры отображённых классов, изменения которых должны попасть в БД, следует регистрировать в специальном реестре. Это требуется для последующей операции «flush». Конечно, требуется поддерживать статус записей. Я обнаружил, что подход «экземпляр отношения» несколько легче реализовать. В частности, можете взглянуть на файлы <tt>DataObject.h</tt>, <tt>DataObject.cpp</tt> и тесты в файле <tt>TestDataObject.cpp</tt> (папка <tt>lib/orm/</tt>). Библиотека YB.ORM использует динамически типизированные объекты внутри и статически типизированные «тонкие» обёртки снаружи. Класс <tt>DataObject</tt> представляет экземпляр отображённого класса, где отображение задаётся в описании метаданных. Подобные объекты всегда выделяются в куче и не копируются. Они хранят значения данных. У них есть ссылка на метаданные для отображаемой таблицы. Конечно, внутри таких объектов поддерживается статус, один из: <tt>New</tt> (вновь созданный), <tt>Ghost</tt> (объект не загружен, есть лишь его ID), <tt>Dirty</tt> (в загруженный объект внесены изменения) <tt>Sync</tt> (объект загружен, изменений не было), <tt>ToBeDeleted</tt> (помечен на удаление), <tt>Deleted</tt> (объект удалён). Чтобы поддержать отношений, в которых данный объект участвует в качестве стороны «n» у каждого объекта есть множество указателей на экземпляры <tt>RelationObject</tt> (поле <tt>slave_relations_</tt>). Чтобы поддержать отношения, в которых данный объект представляет сторону «1» каждый объект имеет также множество умных указателей на экземпляры <tt>RelationObject</tt> (поле <tt>master_relations_</tt>). 

Класс <tt>RelationObject</tt> представляет тот самый экземпляр отношения. Такие объекты также всегда выделяются в куче и не копируются. В них хранятся указатели на связанные экземпляры <tt>DataObject</tt>: один указатель на главный объект отношения, и множество умных указателей подчинённые. Таким образом они «владеют» подчинёнными экземплярами <tt>DataObject</tt>, а главные экземпляры <tt>DataObject</tt> «владеют» (косвенно) всеми подчинёнными. Обратите внимание, что для экземпляров <tt>RelationObject</tt> также поддерживается что-то вроде состояния, для поддержки ленивой загрузки.
